{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { calculateScroll, getFirstScrollableParent, scrollRectangleIntoView } from '../internal/utils/scrollable-containers';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition\n}) {\n  const previousInternalPositionRef = useRef(null);\n  const [popoverStyle, setPopoverStyle] = useState({});\n  const [internalPosition, setInternalPosition] = useState(null);\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef(() => {});\n  const updatePositionHandler = useCallback((onContentResize = false) => {\n    var _a;\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    const track = trackRef.current;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    const {\n      offsetWidth,\n      offsetHeight\n    } = getOffsetDimensions(popover);\n    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevInsetBlockStart = popover.style.insetBlockStart;\n    const prevInsetInlineStart = popover.style.insetInlineStart;\n    popover.style.insetBlockStart = '0';\n    popover.style.insetInlineStart = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxBlockSize = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView);\n    const trackRect = getLogicalBoundingClientRect(track);\n    const arrowRect = getDimensions(arrow);\n    const containingBlock = getContainingBlock(popover);\n    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = getLogicalBoundingClientRect(contentRef.current);\n    const contentBoundingBox = {\n      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n      blockSize: contentRect.blockSize + 2 * bodyBorderWidth\n    };\n    // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n    // we maintain the previously defined internal position,\n    // but we still call calculatePosition to know if the popover should be scrollable.\n    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : undefined;\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      rect\n    } = calculatePosition({\n      preferredPosition,\n      fixedInternalPosition,\n      trigger: trackRect,\n      arrow: arrowRect,\n      body: contentBoundingBox,\n      container: containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewport: viewportRect,\n      renderWithPortal,\n      allowVerticalOverflow\n    });\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(rect, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.insetBlockStart = prevInsetBlockStart;\n    popover.style.insetInlineStart = prevInsetInlineStart;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxBlockSize = rect.blockSize + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Remember the internal position in case we want to keep it later.\n    previousInternalPositionRef.current = newInternalPosition;\n    setInternalPosition(newInternalPosition);\n    const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n    // Position the popover\n    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;\n    setPopoverStyle({\n      insetBlockStart,\n      insetInlineStart: popoverOffset.insetInlineStart\n    });\n    // Scroll if necessary\n    if (shouldScroll) {\n      const scrollableParent = getFirstScrollableParent(popover);\n      scrollRectangleIntoView(rect, scrollableParent);\n    }\n    positionHandlerRef.current = () => {\n      const newTrackOffset = toRelativePosition(getLogicalBoundingClientRect(track), containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);\n      setPopoverStyle({\n        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart\n      });\n    };\n  }, [trackRef, popoverRef, bodyRef, contentRef, arrowRef, keepPosition, allowScrollToFit, preferredPosition, renderWithPortal, allowVerticalOverflow]);\n  return {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef\n  };\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart\n  };\n}\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  var _a, _b, _c, _d;\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: (_b = (_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window.innerWidth,\n    blockSize: (_d = (_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  const {\n    insetBlockStart,\n    insetInlineStart\n  } = getLogicalBoundingClientRect(document.documentElement);\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"names":["useCallback","useRef","useState","nodeContains","getLogicalBoundingClientRect","getContainingBlock","calculateScroll","getFirstScrollableParent","scrollRectangleIntoView","calculatePosition","getDimensions","getOffsetDimensions","usePopoverPosition","popoverRef","bodyRef","arrowRef","trackRef","contentRef","allowScrollToFit","allowVerticalOverflow","preferredPosition","renderWithPortal","keepPosition","previousInternalPositionRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","positionHandlerRef","updatePositionHandler","onContentResize","current","popover","body","arrow","document","ownerDocument","track","offsetWidth","offsetHeight","prevInsetBlockStart","style","insetBlockStart","prevInsetInlineStart","insetInlineStart","maxBlockSize","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","arrowRect","containingBlock","containingBlockRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","inlineSize","blockSize","shouldKeepPosition","fixedInternalPosition","_a","undefined","scrollable","newInternalPosition","rect","trigger","container","getDocumentRect","viewport","popoverOffset","toRelativePosition","trackRelativeOffset","shouldScroll","scrollableParent","newTrackOffset","element","parseInt","getComputedStyle","borderWidth","parent","window","_b","visualViewport","width","innerWidth","_d","_c","height","innerHeight","documentElement","scrollWidth","scrollHeight"],"sources":["/Users/dootano/Desktop/thetekshow-demo-app/node_modules/src/popover/use-popover-position.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getContainingBlock } from '../internal/utils/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<HTMLElement | SVGElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      positionHandlerRef.current = () => {\n        const newTrackOffset = toRelativePosition(\n          getLogicalBoundingClientRect(track),\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      allowScrollToFit,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.visualViewport?.width ?? window.innerWidth,\n    blockSize: window.visualViewport?.height ?? window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n"],"mappings":"AAAA;AACA;AAEA,SAAgBA,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAE5D,SAASC,YAAY,QAAQ,0CAA0C;AACvE,SAASC,4BAA4B,QAAQ,+CAA+C;AAE5F,SAASC,kBAAkB,QAAQ,uBAAuB;AAC1D,SACEC,eAAe,EACfC,wBAAwB,EACxBC,uBAAuB,QAClB,yCAAyC;AAEhD,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,mBAAmB,QAAQ,mBAAmB;AAEzF,eAAc,SAAUC,kBAAkBA,CAAC;EACzCC,UAAU;EACVC,OAAO;EACPC,QAAQ;EACRC,QAAQ;EACRC,UAAU;EACVC,gBAAgB;EAChBC,qBAAqB;EACrBC,iBAAiB;EACjBC,gBAAgB;EAChBC;AAAY,CAYb;EACC,MAAMC,2BAA2B,GAAGtB,MAAM,CAA0B,IAAI,CAAC;EACzE,MAAM,CAACuB,YAAY,EAAEC,eAAe,CAAC,GAAGvB,QAAQ,CAAkB,EAAE,CAAC;EACrE,MAAM,CAACwB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGzB,QAAQ,CAA0B,IAAI,CAAC;EAEvF;EACA,MAAM0B,kBAAkB,GAAG3B,MAAM,CAAa,MAAK,CAAE,CAAC,CAAC;EAEvD,MAAM4B,qBAAqB,GAAG7B,WAAW,CACvC,CAAC8B,eAAe,GAAG,KAAK,KAAI;;IAC1B,IAAI,CAACd,QAAQ,CAACe,OAAO,IAAI,CAAClB,UAAU,CAACkB,OAAO,IAAI,CAACjB,OAAO,CAACiB,OAAO,IAAI,CAACd,UAAU,CAACc,OAAO,IAAI,CAAChB,QAAQ,CAACgB,OAAO,EAAE;MAC5G;;IAGF;IACA,MAAMC,OAAO,GAAGnB,UAAU,CAACkB,OAAO;IAClC,MAAME,IAAI,GAAGnB,OAAO,CAACiB,OAAO;IAC5B,MAAMG,KAAK,GAAGnB,QAAQ,CAACgB,OAAO;IAC9B,MAAMI,QAAQ,GAAGH,OAAO,CAACI,aAAa;IACtC,MAAMC,KAAK,GAAGrB,QAAQ,CAACe,OAAO;IAE9B;IACA;IACA,MAAM;MAAEO,WAAW;MAAEC;IAAY,CAAE,GAAG5B,mBAAmB,CAACqB,OAAO,CAAC;IAClE,IAAIM,WAAW,KAAK,CAAC,IAAIC,YAAY,KAAK,CAAC,IAAI,CAACpC,YAAY,CAACgC,QAAQ,CAACF,IAAI,EAAEI,KAAK,CAAC,EAAE;MAClF;;IAGF;IACA;IACA;IACA,MAAMG,mBAAmB,GAAGR,OAAO,CAACS,KAAK,CAACC,eAAe;IACzD,MAAMC,oBAAoB,GAAGX,OAAO,CAACS,KAAK,CAACG,gBAAgB;IAE3DZ,OAAO,CAACS,KAAK,CAACC,eAAe,GAAG,GAAG;IACnCV,OAAO,CAACS,KAAK,CAACG,gBAAgB,GAAG,GAAG;IACpC;IACAX,IAAI,CAACQ,KAAK,CAACI,YAAY,GAAG,EAAE;IAC5BZ,IAAI,CAACQ,KAAK,CAACK,SAAS,GAAG,EAAE;IACzBb,IAAI,CAACQ,KAAK,CAACM,SAAS,GAAG,EAAE;IAEzB;IACA;IACA,MAAMC,YAAY,GAAGC,eAAe,CAACd,QAAQ,CAACe,WAAY,CAAC;IAC3D,MAAMC,SAAS,GAAG/C,4BAA4B,CAACiC,KAAK,CAAC;IACrD,MAAMe,SAAS,GAAG1C,aAAa,CAACwB,KAAK,CAAC;IACtC,MAAMmB,eAAe,GAAGhD,kBAAkB,CAAC2B,OAAO,CAAC;IACnD,MAAMsB,mBAAmB,GAAGD,eAAe,GAAGjD,4BAA4B,CAACiD,eAAe,CAAC,GAAGL,YAAY;IAE1G,MAAMO,eAAe,GAAGC,cAAc,CAACvB,IAAI,CAAC;IAC5C,MAAMwB,WAAW,GAAGrD,4BAA4B,CAACa,UAAU,CAACc,OAAO,CAAC;IACpE,MAAM2B,kBAAkB,GAAG;MACzBC,UAAU,EAAEF,WAAW,CAACE,UAAU,GAAG,CAAC,GAAGJ,eAAe;MACxDK,SAAS,EAAEH,WAAW,CAACG,SAAS,GAAG,CAAC,GAAGL;KACxC;IAED;IACA;IACA;IACA,MAAMM,kBAAkB,GAAGvC,YAAY,IAAIQ,eAAe,IAAI,CAAC,CAACP,2BAA2B,CAACQ,OAAO;IACnG,MAAM+B,qBAAqB,GAAG,CAAAC,EAAA,GAACF,kBAAkB,IAAItC,2BAA2B,CAACQ,OAAQ,cAAAgC,EAAA,cAAAA,EAAA,GAAIC,SAAS;IAEtG;IACA,MAAM;MACJC,UAAU;MACVvC,gBAAgB,EAAEwC,mBAAmB;MACrCC;IAAI,CACL,GAAG1D,iBAAiB,CAAC;MACpBW,iBAAiB;MACjB0C,qBAAqB;MACrBM,OAAO,EAAEjB,SAAS;MAClBjB,KAAK,EAAEkB,SAAS;MAChBnB,IAAI,EAAEyB,kBAAkB;MACxBW,SAAS,EAAEhB,eAAe,GAAGC,mBAAmB,GAAGgB,eAAe,CAACnC,QAAQ,CAAC;MAC5EoC,QAAQ,EAAEvB,YAAY;MACtB3B,gBAAgB;MAChBF;KACD,CAAC;IAEF;IACA,MAAMqD,aAAa,GAAGC,kBAAkB,CAACN,IAAI,EAAEb,mBAAmB,CAAC;IAEnE;IACA;IACA,MAAMoB,mBAAmB,GAAGD,kBAAkB,CAACD,aAAa,EAAEC,kBAAkB,CAACtB,SAAS,EAAEG,mBAAmB,CAAC,CAAC;IAEjH;IACAtB,OAAO,CAACS,KAAK,CAACC,eAAe,GAAGF,mBAAmB;IACnDR,OAAO,CAACS,KAAK,CAACG,gBAAgB,GAAGD,oBAAoB;IAErD;IACA,IAAIsB,UAAU,EAAE;MACdhC,IAAI,CAACQ,KAAK,CAACI,YAAY,GAAGsB,IAAI,CAACP,SAAS,GAAG,IAAI;MAC/C3B,IAAI,CAACQ,KAAK,CAACK,SAAS,GAAG,QAAQ;MAC/Bb,IAAI,CAACQ,KAAK,CAACM,SAAS,GAAG,MAAM;;IAG/B;IACAxB,2BAA2B,CAACQ,OAAO,GAAGmC,mBAAmB;IACzDvC,mBAAmB,CAACuC,mBAAmB,CAAC;IAExC,MAAMS,YAAY,GAAGzD,gBAAgB,IAAI,CAAC2C,kBAAkB;IAE5D;IACA,MAAMnB,eAAe,GAAGiC,YAAY,GAChCH,aAAa,CAAC9B,eAAe,GAAGpC,eAAe,CAAC6D,IAAI,CAAC,GACrDK,aAAa,CAAC9B,eAAe;IACjCjB,eAAe,CAAC;MAAEiB,eAAe;MAAEE,gBAAgB,EAAE4B,aAAa,CAAC5B;IAAgB,CAAE,CAAC;IAEtF;IACA,IAAI+B,YAAY,EAAE;MAChB,MAAMC,gBAAgB,GAAGrE,wBAAwB,CAACyB,OAAO,CAAC;MAC1DxB,uBAAuB,CAAC2D,IAAI,EAAES,gBAAgB,CAAC;;IAGjDhD,kBAAkB,CAACG,OAAO,GAAG,MAAK;MAChC,MAAM8C,cAAc,GAAGJ,kBAAkB,CACvCrE,4BAA4B,CAACiC,KAAK,CAAC,EACnCgB,eAAe,GAAGjD,4BAA4B,CAACiD,eAAe,CAAC,GAAGL,YAAY,CAC/E;MACDvB,eAAe,CAAC;QACdiB,eAAe,EAAEmC,cAAc,CAACnC,eAAe,GAAGgC,mBAAmB,CAAChC,eAAe;QACrFE,gBAAgB,EAAEiC,cAAc,CAACjC,gBAAgB,GAAG8B,mBAAmB,CAAC9B;OACzE,CAAC;IACJ,CAAC;EACH,CAAC,EACD,CACE5B,QAAQ,EACRH,UAAU,EACVC,OAAO,EACPG,UAAU,EACVF,QAAQ,EACRO,YAAY,EACZJ,gBAAgB,EAChBE,iBAAiB,EACjBC,gBAAgB,EAChBF,qBAAqB,CACtB,CACF;EACD,OAAO;IAAEU,qBAAqB;IAAEL,YAAY;IAAEE,gBAAgB;IAAEE;EAAkB,CAAE;AACtF;AAEA,SAAS4B,cAAcA,CAACsB,OAAoB;EAC1C,OAAOC,QAAQ,CAACC,gBAAgB,CAACF,OAAO,CAAC,CAACG,WAAW,CAAC,IAAI,CAAC;AAC7D;AAEA;;;AAGA,SAASR,kBAAkBA,CAACK,OAAe,EAAEI,MAAc;EACzD,OAAO;IACLxC,eAAe,EAAEoC,OAAO,CAACpC,eAAe,GAAGwC,MAAM,CAACxC,eAAe;IACjEE,gBAAgB,EAAEkC,OAAO,CAAClC,gBAAgB,GAAGsC,MAAM,CAACtC;GACrD;AACH;AAEA;;;AAGA,SAASK,eAAeA,CAACkC,MAAc;;EACrC,OAAO;IACLzC,eAAe,EAAE,CAAC;IAClBE,gBAAgB,EAAE,CAAC;IACnBe,UAAU,EAAE,CAAAyB,EAAA,IAAArB,EAAA,GAAAoB,MAAM,CAACE,cAAc,cAAAtB,EAAA,uBAAAA,EAAA,CAAEuB,KAAK,cAAAF,EAAA,cAAAA,EAAA,GAAID,MAAM,CAACI,UAAU;IAC7D3B,SAAS,EAAE,CAAA4B,EAAA,IAAAC,EAAA,GAAAN,MAAM,CAACE,cAAc,cAAAI,EAAA,uBAAAA,EAAA,CAAEC,MAAM,cAAAF,EAAA,cAAAA,EAAA,GAAIL,MAAM,CAACQ;GACpD;AACH;AAEA,SAASrB,eAAeA,CAACnC,QAAkB;EACzC,MAAM;IAAEO,eAAe;IAAEE;EAAgB,CAAE,GAAGxC,4BAA4B,CAAC+B,QAAQ,CAACyD,eAAe,CAAC;EAEpG,OAAO;IACLlD,eAAe;IACfE,gBAAgB;IAChBe,UAAU,EAAExB,QAAQ,CAACyD,eAAe,CAACC,WAAW;IAChDjC,SAAS,EAAEzB,QAAQ,CAACyD,eAAe,CAACE;GACrC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}