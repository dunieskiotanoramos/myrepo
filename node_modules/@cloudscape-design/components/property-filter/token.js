// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useRef, useState } from 'react';
import FilteringToken from './filtering-token';
import { TokenEditor } from './token-editor';
import { getFormattedToken } from './utils';
import styles from './styles.css.js';
export const TokenButton = ({ token, operation = 'and', first, removeToken, setToken, setOperation, filteringProperties, filteringOptions, asyncProps, onLoadItems, i18nStrings, asyncProperties, hideOperations, customGroupsText, disabled, freeTextFiltering, expandToViewport, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const tokenRef = useRef(null);
    const externalToken = Object.assign(Object.assign({}, token), { propertyKey: (_a = token.property) === null || _a === void 0 ? void 0 : _a.propertyKey });
    const formattedToken = getFormattedToken(token);
    const [temporaryToken, setTemporaryToken] = useState(token);
    return (React.createElement(FilteringToken, { ref: tokenRef, tokens: [
            {
                content: (React.createElement("span", { className: styles['token-trigger'] },
                    React.createElement(TokenTrigger, { property: formattedToken.property, operator: token.operator, value: formattedToken.value }))),
                ariaLabel: formattedToken.label,
                dismissAriaLabel: (_c = (_b = i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.removeTokenButtonAriaLabel) === null || _b === void 0 ? void 0 : _b.call(i18nStrings, externalToken)) !== null && _c !== void 0 ? _c : '',
            },
        ], showOperation: !first && !hideOperations, operation: operation, andText: (_d = i18nStrings.operationAndText) !== null && _d !== void 0 ? _d : '', orText: (_e = i18nStrings.operationOrText) !== null && _e !== void 0 ? _e : '', operationAriaLabel: (_f = i18nStrings.tokenOperatorAriaLabel) !== null && _f !== void 0 ? _f : '', onChangeOperation: setOperation, onDismissToken: removeToken, disabled: disabled, editorContent: React.createElement(TokenEditor, { setToken: setToken, filteringProperties: filteringProperties, filteringOptions: filteringOptions, temporaryToken: temporaryToken, onChangeTemporaryToken: setTemporaryToken, asyncProps: asyncProps, onLoadItems: onLoadItems, i18nStrings: i18nStrings, asyncProperties: asyncProperties, customGroupsText: customGroupsText, freeTextFiltering: freeTextFiltering, onDismiss: () => { var _a; return (_a = tokenRef.current) === null || _a === void 0 ? void 0 : _a.closeEditor(); } }), editorHeader: (_g = i18nStrings.editTokenHeader) !== null && _g !== void 0 ? _g : '', editorDismissAriaLabel: (_h = i18nStrings.dismissAriaLabel) !== null && _h !== void 0 ? _h : '', editorExpandToViewport: !!expandToViewport, onEditorOpen: () => setTemporaryToken(token), 
        // The properties below are only relevant for grouped tokens that are not supported
        // by the property filter component yet.
        groupOperation: operation, groupAriaLabel: '', groupEditAriaLabel: '', onChangeGroupOperation: () => { }, hasGroups: false }));
};
const TokenTrigger = ({ property, operator, value, }) => {
    if (property) {
        property += ' ';
    }
    const freeTextContainsToken = operator === ':' && !property;
    const operatorText = freeTextContainsToken ? '' : operator + ' ';
    return (React.createElement(React.Fragment, null,
        property,
        React.createElement("span", { className: styles['token-operator'] }, operatorText),
        value));
};
//# sourceMappingURL=token.js.map