// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect, useRef } from 'react';
import clsx from 'clsx';
import { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';
import { InternalBreadcrumbGroup } from '../../../breadcrumb-group/internal';
import { createWidgetizedComponent } from '../../../internal/widgets';
import { ToolbarSlot } from '../skeleton/slot-wrappers';
import { DrawerTriggers } from './drawer-triggers';
import TriggerButton from './trigger-button';
import testutilStyles from '../../test-classes/styles.css.js';
import styles from './styles.css.js';
export function AppLayoutToolbarImplementation({ appLayoutInternals, toolbarProps, }) {
    var _a;
    const { breadcrumbs, discoveredBreadcrumbs, verticalOffsets, isMobile, toolbarState, setToolbarState, setToolbarHeight, } = appLayoutInternals;
    const { ariaLabels, activeDrawerId, drawers, drawersFocusRef, onActiveDrawerChange, hasNavigation, navigationOpen, navigationFocusRef, onNavigationToggle, hasSplitPanel, splitPanelFocusRef, splitPanelToggleProps, onSplitPanelToggle, } = toolbarProps;
    // TODO: expose configuration property
    const pinnedToolbar = true;
    const ref = useRef(null);
    useResizeObserver(ref, entry => setToolbarHeight(entry.borderBoxHeight));
    useEffect(() => {
        return () => {
            setToolbarHeight(0);
        };
        // unmount effect only
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useEffect(() => {
        let lastScrollY = window.scrollY;
        /* istanbul ignore next not testable in JSDOM */
        const updateScrollDirection = () => {
            if (pinnedToolbar) {
                setToolbarState('show');
                return;
            }
            const scrollY = window.scrollY;
            // 80 is an arbitrary number to have a pause before the toolbar scrolls out of view at the top of the page
            const direction = scrollY > lastScrollY && scrollY > 80 ? 'hide' : 'show';
            // 2 as a buffer to avoid mistaking minor accidental mouse moves as scroll
            if (direction !== toolbarState && (scrollY - lastScrollY > 2 || scrollY - lastScrollY < -2)) {
                setToolbarState(direction);
            }
            lastScrollY = scrollY > 0 ? scrollY : 0;
        };
        window.addEventListener('scroll', updateScrollDirection);
        return () => {
            window.removeEventListener('scroll', updateScrollDirection);
        };
    }, [pinnedToolbar, setToolbarState, toolbarState]);
    const toolbarHidden = toolbarState === 'hide' && !pinnedToolbar;
    return (React.createElement(ToolbarSlot, { ref: ref, className: clsx(styles['universal-toolbar'], {
            [testutilStyles['mobile-bar']]: isMobile,
            [styles['toolbar-hidden']]: toolbarHidden,
        }), style: {
            insetBlockStart: toolbarHidden ? '-60px' : verticalOffsets.toolbar,
        } },
        React.createElement("div", { className: styles['toolbar-container'] },
            hasNavigation && !navigationOpen && (React.createElement("nav", { className: clsx(styles['universal-toolbar-nav'], testutilStyles['drawer-closed']) },
                React.createElement(TriggerButton, { ariaLabel: (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.navigationToggle) !== null && _a !== void 0 ? _a : undefined, ariaExpanded: false, iconName: "menu", className: testutilStyles['navigation-toggle'], onClick: () => onNavigationToggle === null || onNavigationToggle === void 0 ? void 0 : onNavigationToggle(true), ref: navigationFocusRef, selected: navigationOpen }))),
            (breadcrumbs || discoveredBreadcrumbs) && (React.createElement("div", { className: clsx(styles['universal-toolbar-breadcrumbs'], testutilStyles.breadcrumbs) },
                breadcrumbs,
                discoveredBreadcrumbs && React.createElement(InternalBreadcrumbGroup, Object.assign({}, discoveredBreadcrumbs)))),
            ((drawers && drawers.length > 0) || (hasSplitPanel && (splitPanelToggleProps === null || splitPanelToggleProps === void 0 ? void 0 : splitPanelToggleProps.displayed))) && (React.createElement("span", { className: clsx(styles['universal-toolbar-drawers']) },
                React.createElement(DrawerTriggers, { ariaLabels: ariaLabels, activeDrawerId: activeDrawerId !== null && activeDrawerId !== void 0 ? activeDrawerId : null, drawers: drawers !== null && drawers !== void 0 ? drawers : [], drawersFocusRef: drawersFocusRef, onActiveDrawerChange: onActiveDrawerChange, splitPanelToggleProps: (splitPanelToggleProps === null || splitPanelToggleProps === void 0 ? void 0 : splitPanelToggleProps.displayed) ? splitPanelToggleProps : undefined, splitPanelFocusRef: splitPanelFocusRef, onSplitPanelToggle: onSplitPanelToggle }))))));
}
export const createWidgetizedAppLayoutToolbar = createWidgetizedComponent(AppLayoutToolbarImplementation);
//# sourceMappingURL=index.js.map